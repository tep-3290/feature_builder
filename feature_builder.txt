# ============================================================
# PART 1 / 5 : 高速インジケータ（ATR / RSI / MACD / DTW）
# ============================================================

import numpy as np
from concurrent.futures import ThreadPoolExecutor, as_completed

# =========================================
# 入出力パス（MQL4 連携）
# =========================================
input_path = r"C:\Users\arei_\AppData\Roaming\MetaQuotes\Terminal\34B08C83A5AAE27A4079DE708E60511E\MQL4\Files\USDJPY_py.csv"
output_path = r"C:\Users\arei_\AppData\Roaming\MetaQuotes\Terminal\34B08C83A5AAE27A4079DE708E60511E\MQL4\Files\nextbar.txt"

# 類似パターンの最大数
MAX_HISTORY_WINDOWS = 2000

# 類似度の時間減衰係数
TIME_DECAY_TAU = 300.0
# ------------------------------------------------------------
# fast_atr : 高速 ATR（Wilder EMA）
# ------------------------------------------------------------
def fast_atr(high: np.ndarray, low: np.ndarray, close: np.ndarray, period: int) -> np.ndarray:
    """
    高速 ATR（Wilder EMA）
    - 完全ベクトル化
    - 安定性のため prev_close を使用
    - period が大きくても高速
    """
    tr1 = high - low
    prev_close = np.concatenate(([close[0]], close[:-1]))
    tr2 = np.abs(high - prev_close)
    tr3 = np.abs(low - prev_close)
    tr = np.maximum(np.maximum(tr1, tr2), tr3)

    atr = np.empty_like(tr)
    alpha = 1.0 / period
    atr[0] = tr[0]

    for i in range(1, len(tr)):
        atr[i] = (1 - alpha) * atr[i - 1] + alpha * tr[i]

    return atr


# ------------------------------------------------------------
# fast_rsi : 高速 RSI（Wilder EMA）
# ------------------------------------------------------------
def fast_rsi(close: np.ndarray, period: int = 14) -> np.ndarray:
    """
    高速 RSI（Wilder EMA）
    - 完全ベクトル化
    - deltas から up/down を抽出
    """
    deltas = np.diff(close, prepend=close[0])
    ups = np.where(deltas > 0, deltas, 0.0)
    downs = np.where(deltas < 0, -deltas, 0.0)

    avg_up = np.empty_like(close)
    avg_down = np.empty_like(close)

    alpha = 1.0 / period
    avg_up[0] = ups[0]
    avg_down[0] = downs[0]

    for i in range(1, len(close)):
        avg_up[i] = (1 - alpha) * avg_up[i - 1] + alpha * ups[i]
        avg_down[i] = (1 - alpha) * avg_down[i - 1] + alpha * downs[i]

    rs = np.where(avg_down == 0, 0, avg_up / avg_down)
    return 100 - (100 / (1 + rs))


# ------------------------------------------------------------
# fast_macd : 高速 MACD（EMA 差分）
# ------------------------------------------------------------
def fast_macd(close: np.ndarray, fast: int = 12, slow: int = 26) -> np.ndarray:
    """
    高速 MACD（EMA 差分）
    - EMA を2本計算して差分を返す
    """
    def ema(series, period):
        alpha = 2.0 / (period + 1)
        out = np.empty_like(series)
        out[0] = series[0]
        for i in range(1, len(series)):
            out[i] = alpha * series[i] + (1 - alpha) * out[i - 1]
        return out

    return ema(close, fast) - ema(close, slow)


# ------------------------------------------------------------
# dtw_distance_early : 価格系列専用 DTW（早期打ち切り）
# ------------------------------------------------------------
def dtw_distance_early(a: np.ndarray, b: np.ndarray, window: int) -> float:
    """
    価格系列専用 DTW（Dynamic Time Warping）
    - window による制限で高速化
    - early abandon（途中終了）でさらに高速化
    - 類似度計算の安定性を重視
    """
    na = len(a)
    nb = len(b)
    if na == 0 or nb == 0:
        return 1e18

    w = max(window, abs(na - nb))
    INF = 1e18

    prev = np.full(nb + 1, INF)
    cur = np.full(nb + 1, INF)
    prev[0] = 0.0

    for i in range(1, na + 1):
        start_j = max(1, i - w)
        end_j = min(nb, i + w)
        cur.fill(INF)

        ai = a[i - 1]

        for j in range(start_j, end_j + 1):
            cost = abs(ai - b[j - 1])
            cur[j] = cost + min(prev[j], cur[j - 1], prev[j - 1])

        prev, cur = cur, prev

        # early abandon
        if np.min(prev[start_j:end_j + 1]) > 1e12:
            return float(INF)

    return float(prev[nb])
# ============================================================
# PART 2 / 5 : 特徴量（固定次元 Price Shape + Market/Vol）
# ============================================================

import numpy as np
import pandas as pd

# ------------------------------------------------------------
# build_price_shape_features : 固定 24 次元の価格形状特徴量
# ------------------------------------------------------------
def build_price_shape_features(df: pd.DataFrame, N: int, atr_series: np.ndarray) -> np.ndarray:
    """
    N 本のローソク足から「固定 24 次元」の特徴量を生成する。
    - N に依存しないため、類似度空間が安定する
    - 実体・ヒゲ・レンジ・方向性・ボラティリティ・傾きなどを統合
    - 価格形状の本質を抽出するための最適化済みセット
    """

    o = df['Open'].values
    h = df['High'].values
    l = df['Low'].values
    c = df['Close'].values
    v = df['Volume'].values if 'Volume' in df.columns else np.zeros_like(c)

    total = len(df)
    windows = total - N + 1
    if windows <= 0:
        raise ValueError("Not enough bars for the requested N in build_price_shape_features.")

    feat_len = 24
    mat = np.zeros((windows, feat_len), dtype=float)

    bodies = c - o
    upper_wicks = h - np.maximum(o, c)
    lower_wicks = np.minimum(o, c) - l
    ranges = h - l
    ranges[ranges == 0] = 1e-8

    body_abs = np.abs(bodies)
    wick_total = upper_wicks + lower_wicks

    for i in range(windows):
        start = i
        stop = i + N

        bs = bodies[start:stop]
        ba = body_abs[start:stop]
        uw = upper_wicks[start:stop]
        lw = lower_wicks[start:stop]
        wt = wick_total[start:stop]
        rg = ranges[start:stop]
        cl = c[start:stop]
        op = o[start:stop]
        vol = v[start:stop]

        atr_val = max(1e-8, atr_series[start:stop].mean())

        # -------------------------
        # 1. 実体の統計量
        # -------------------------
        body_mean = bs.mean()
        body_std = bs.std()
        body_abs_mean = ba.mean()
        body_abs_std = ba.std()

        # -------------------------
        # 2. ヒゲの統計量
        # -------------------------
        uw_mean = uw.mean()
        lw_mean = lw.mean()
        wick_total_mean = wt.mean()
        wick_ratio_mean = (wt / rg).mean()

        # -------------------------
        # 3. レンジの統計量
        # -------------------------
        range_mean = rg.mean()
        range_std = rg.std()
        range_atr_ratio = range_mean / atr_val

        # -------------------------
        # 4. 陽線率・陰線率・連続本数
        # -------------------------
        up_mask = bs > 0
        down_mask = bs < 0
        up_ratio = up_mask.mean()
        down_ratio = down_mask.mean()

        max_up_run = 0
        max_down_run = 0
        cur_up = 0
        cur_down = 0
        for b in bs:
            if b > 0:
                cur_up += 1
                cur_down = 0
            elif b < 0:
                cur_down += 1
                cur_up = 0
            else:
                cur_up = 0
                cur_down = 0
            max_up_run = max(max_up_run, cur_up)
            max_down_run = max(max_down_run, cur_down)

        # -------------------------
        # 5. ボラティリティ（Volume）
        # -------------------------
        vol_mean = vol.mean()
        vol_std = vol.std()
        vol_atr_ratio = vol_mean / (np.mean(atr_series[start:stop]) + 1e-8)

        # -------------------------
        # 6. 価格の傾き（線形回帰）
        # -------------------------
        x = np.arange(len(cl))
        if len(cl) >= 2:
            A = np.vstack([x, np.ones_like(x)]).T
            m, _ = np.linalg.lstsq(A, cl, rcond=None)[0]
        else:
            m = 0.0
        slope_norm = m / atr_val

        # -------------------------
        # 7. 価格位置（レンジ内の相対位置）
        # -------------------------
        high_win = cl.max()
        low_win = cl.min()
        last_close = cl[-1]
        pos_in_range = (last_close - low_win) / max(high_win - low_win, 1e-8)

        # -------------------------
        # 8. 実体 vs レンジ比
        # -------------------------
        body_range_ratio_mean = (ba / rg).mean()

        # -------------------------
        # 9. 最終バーの特徴
        # -------------------------
        last_body_norm = bs[-1] / atr_val
        last_wick_norm = wt[-1] / atr_val
        total_move_norm = (cl[-1] - op[0]) / atr_val

        # -------------------------
        # 24次元ベクトルに詰める
        # -------------------------
        row = [
            body_mean, body_std, body_abs_mean, body_abs_std,
            uw_mean, lw_mean, wick_total_mean, wick_ratio_mean,
            range_mean, range_std, range_atr_ratio,
            up_ratio, down_ratio, max_up_run, max_down_run,
            vol_mean, vol_std, vol_atr_ratio,
            slope_norm, pos_in_range, body_range_ratio_mean,
            last_body_norm, last_wick_norm, total_move_norm
        ]

        mat[i, :] = row

    return mat


# ------------------------------------------------------------
# build_market_vol_features : 固定 15 次元の市場構造特徴量
# ------------------------------------------------------------
def build_market_vol_features(df: pd.DataFrame, N: int, atr_series: np.ndarray) -> np.ndarray:
    """
    市場構造（トレンド・レンジ・ボラティリティ）を表す固定 15 次元特徴量。
    - トレンド強度
    - レンジ幅
    - ブレイクアウト距離
    - モメンタム（ROC / RSI / CCI / MACD）
    - 出来高
    """

    h = df['High'].values
    l = df['Low'].values
    c = df['Close'].values
    v = df['Volume'].values if 'Volume' in df.columns else np.zeros_like(c)

    total = len(df)
    windows = total - N + 1
    feat_len = 15
    mat = np.zeros((windows, feat_len), dtype=float)

    for i in range(windows):
        start = i
        stop = i + N

        highs = h[start:stop]
        lows = l[start:stop]
        closes = c[start:stop]
        vols = v[start:stop] if len(v) > 0 else np.zeros_like(closes)

        # -------------------------
        # 1. トレンド傾き（線形回帰）
        # -------------------------
        x = np.arange(len(closes))
        if len(closes) >= 2:
            A = np.vstack([x, np.ones_like(x)]).T
            m, _ = np.linalg.lstsq(A, closes, rcond=None)[0]
        else:
            m = 0.0

        # 前半・後半の傾き変化
        half = max(1, len(closes) // 2)
        slope1 = 0.0
        slope2 = 0.0
        if half >= 2:
            x1 = np.arange(half)
            m1, _ = np.linalg.lstsq(np.vstack([x1, np.ones_like(x1)]).T, closes[:half], rcond=None)[0]
            slope1 = m1
        if len(closes) - half >= 2:
            x2 = np.arange(len(closes) - half)
            m2, _ = np.linalg.lstsq(np.vstack([x2, np.ones_like(x2)]).T, closes[half:], rcond=None)[0]
            slope2 = m2

        slope_change = 0.0 if abs(slope1) < 1e-12 else (slope2 - slope1) / (abs(slope1) + 1e-8)

        # -------------------------
        # 2. ATR 正規化トレンド強度
        # -------------------------
        atr_val = max(1e-8, atr_series[stop - 1])
        trend_strength = m / atr_val

        # -------------------------
        # 3. レンジ構造
        # -------------------------
        highs_roll_max = np.max(highs)
        lows_roll_min = np.min(lows)

        hh = int(highs[-1] > np.max(highs[:-1])) if len(highs) > 1 else 0
        ll = int(lows[-1] < np.min(lows[:-1])) if len(lows) > 1 else 0

        range_width = (highs_roll_max - lows_roll_min) / atr_val
        range_position = (closes[-1] - lows_roll_min) / max((highs_roll_max - lows_roll_min), 1e-8)

        # -------------------------
        # 4. ブレイクアウト距離
        # -------------------------
        breakout_distance = 0.0
        if closes[-1] > highs_roll_max:
            breakout_distance = (closes[-1] - highs_roll_max) / atr_val
        elif closes[-1] < lows_roll_min:
            breakout_distance = (lows_roll_min - closes[-1]) / atr_val

        breakout_volume_ratio = vols[-1] / (np.mean(vols) + 1e-8) if len(vols) > 0 else 0.0

        # -------------------------
        # 5. モメンタム系
        # -------------------------
        atr_norm = atr_val / max(abs(closes[-1]), 1e-8)

        roc_val = 0.0
        if len(closes) > 1:
            roc_val = (closes[-1] - closes[0]) / max(abs(closes[0]), 1e-8)

        rsi_val = fast_rsi(closes, period=min(14, max(2, len(closes))))[-1]

        tp = (highs + lows + closes) / 3.0
        ma = np.mean(tp)
        mean_dev = np.mean(np.abs(tp - ma)) if len(tp) > 0 else 0.0
        cci_val = (tp[-1] - ma) / (0.015 * mean_dev) if mean_dev > 1e-8 else 0.0

        macd_val = fast_macd(closes)[-1] if len(closes) >= 2 else 0.0

        vol_mean = np.mean(vols) if len(vols) > 0 else 0.0

        # -------------------------
        # 15次元ベクトルに詰める
        # -------------------------
        row = [
            m, slope_change, trend_strength,
            hh, ll,
            range_width, range_position,
            breakout_distance, breakout_volume_ratio,
            atr_norm, roc_val, rsi_val, cci_val, macd_val,
            vol_mean
        ]

        mat[i, :] = row

    return mat
# ============================================================
# PART 3 / 5 : 類似度エンジン（Cosine + DTW + 時間減衰 + 動的 top_k）
# ============================================================

import numpy as np
from concurrent.futures import ThreadPoolExecutor, as_completed

# ------------------------------------------------------------
# compute_similarities_fast :
#   - コサイン類似度（全パターン）
#   - DTW（価格系列 top_k のみ）
#   - 時間減衰（exp decay）
#   - ATR に応じた top_k の動的調整
# ------------------------------------------------------------
def compute_similarities_fast(
    current_vec: np.ndarray,
    past_matrix: np.ndarray,
    current_price_seq: np.ndarray,
    past_price_seqs: np.ndarray,
    top_k: int,
    dtw_window: int | None = None,
    tau: float = 300.0,
):
    eps = 1e-12
    if len(past_matrix) == 0:
        return np.zeros(0, dtype=float), np.zeros(0, dtype=float)

    # ---- 特徴量を標準化してから cosine ----
    all_mat = np.vstack([past_matrix, current_vec[None, :]])
    mean = all_mat.mean(axis=0)
    std = all_mat.std(axis=0) + 1e-8
    all_norm = (all_mat - mean) / std

    past_norm_mat = all_norm[:-1]
    cur_norm_vec = all_norm[-1]

    cur_norm = np.linalg.norm(cur_norm_vec) + eps
    past_norms = np.linalg.norm(past_norm_mat, axis=1) + eps
    cos_sims = (past_norm_mat @ cur_norm_vec) / (past_norms * cur_norm)
    cos_sims = np.nan_to_num(cos_sims, nan=0.0)

    sims = np.copy(cos_sims)

    # ---- DTW（ATR 正規化 or 差分） ----
    k = min(top_k, len(cos_sims))
    top_idx = np.argsort(-cos_sims)[:k]

    dtw_results = np.zeros(k, dtype=float)
    cur = current_price_seq.astype(float)
    # 差分 + 正規化
    cur_diff = np.diff(cur)
    cur_diff = cur_diff / (np.std(cur_diff) + 1e-8)

    window = dtw_window if dtw_window is not None else len(cur_diff)

    with ThreadPoolExecutor(max_workers=8) as ex:
        futures = {}
        for j, i in enumerate(top_idx):
            seq = past_price_seqs[i].astype(float)
            seq_diff = np.diff(seq)
            seq_diff = seq_diff / (np.std(seq_diff) + 1e-8)
            futures[ex.submit(dtw_distance_early, cur_diff, seq_diff, window)] = j

        for fut in as_completed(futures):
            j = futures[fut]
            try:
                dtw_results[j] = fut.result()
            except Exception:
                dtw_results[j] = 1e18

    sim_dtw = 1.0 / (1.0 + dtw_results)

    # ---- time decay ----
    ages = np.arange(len(past_matrix))[::-1]
    top_ages = ages[top_idx]
    top_time_weights = np.exp(-top_ages / tau)

    # ---- 統合 ----
    for j, i in enumerate(top_idx):
        sims[i] = (0.7 * cos_sims[i] + 0.3 * sim_dtw[j]) * top_time_weights[j]

    return sims, cos_sims
# ============================================================
# PART 4 / 5 : 状態判定（Z-score 動的判定）
# ============================================================

import numpy as np
import pandas as pd
import json
# ==============================
# 状態判定ロジック（修正版）
# ==============================
def determine_state_dynamic(cur_window: pd.DataFrame, atr_series: np.ndarray, N: int) -> str:
    closes = cur_window["Close"].values
    highs  = cur_window["High"].values
    lows   = cur_window["Low"].values
    opens  = cur_window["Open"].values

    atr_val  = max(1e-8, atr_series[-1])

    # ---- 傾き（クローズの線形回帰） ----
    x = np.arange(len(closes))
    if len(closes) >= 2:
        A = np.vstack([x, np.ones_like(x)]).T
        m, _ = np.linalg.lstsq(A, closes, rcond=None)[0]
    else:
        m = 0.0
    slope_norm = m / atr_val

    # 過去の傾き分布（ATR 正規化済み）
    lookback = min(300, len(atr_series), len(cur_window) + len(atr_series))
    # 過去 N 本ずつの傾きをざっくり取る
    slope_hist = []
    if lookback > N + 10:
        for i in range(N, lookback):
            seg = closes[max(0, i - N):i]
            if len(seg) >= 2:
                xx = np.arange(len(seg))
                AA = np.vstack([xx, np.ones_like(xx)]).T
                mm, _ = np.linalg.lstsq(AA, seg, rcond=None)[0]
                slope_hist.append(mm / max(1e-8, atr_val))
    if len(slope_hist) < 10:
        slope_z = 0.0
    else:
        slope_hist = np.array(slope_hist)
        slope_z = (slope_norm - slope_hist.mean()) / (slope_hist.std() + 1e-8)

    # ---- ATR Z-score ----
    atr_lookback = min(300, len(atr_series))
    atr_hist = atr_series[-atr_lookback:]
    atr_z = (atr_val - atr_hist.mean()) / (atr_hist.std() + 1e-8)

    # ---- HH / LL ----
    hh = highs[-1] > np.max(highs[:-1]) if len(highs) > 1 else False
    ll = lows[-1]  < np.min(lows[:-1]) if len(lows) > 1 else False

    # ---- ブレイク距離 ----
    range_high = np.max(highs)
    range_low  = np.min(lows)
    close_last = closes[-1]

    breakout_dist = 0.0
    if close_last > range_high:
        breakout_dist = (close_last - range_high) / atr_val
    elif close_last < range_low:
        breakout_dist = (range_low - close_last) / atr_val

    # 過去レンジ幅 / ATR の分布から Z-score
    range_hist = []
    if atr_lookback > N + 10:
        for i in range(N, atr_lookback):
            # ATR と同じインデックスでレンジ幅を近似
            # ここでは cur_window のスケールで代用（厳密さより一貫性優先）
            rng = (range_high - range_low) / max(1e-8, atr_hist[i - 1])
            range_hist.append(rng)

    if len(range_hist) < 10:
        breakout_z = 0.0
    else:
        range_hist = np.array(range_hist)
        breakout_z = (breakout_dist - range_hist.mean()) / (range_hist.std() + 1e-8)

    # ---- 直近の値動き方向 ----
    bodies = closes - opens
    signs = np.sign(bodies[-5:]) if len(bodies) >= 5 else np.sign(bodies)
    price_signal = int(np.sign(np.sum(signs)))  # -1 / 0 / +1

    # ---- 状態判定 ----
    # 1. 強いトレンド
    if slope_z > 0.7 and hh:
        return "trend_up"
    if slope_z < -0.7 and ll:
        return "trend_down"

    # 2. ブレイクアウト
    if breakout_z > 1.2 and abs(price_signal) == 1:
        return "range_breakout"

    # 3. レンジ
    if abs(slope_z) < 0.3 and abs(atr_z) < 0.5:
        mid = (range_high + range_low) / 2
        return "range_up" if close_last > mid else "range_down"

    # 4. トレンド終了気味
    trend_up_end = (slope_z < 0.2 and atr_z < -0.3 and price_signal <= 0)
    trend_down_end = (slope_z > -0.2 and atr_z < -0.3 and price_signal >= 0)

    if trend_up_end:
        return "trend_up_end"
    if trend_down_end:
        return "trend_down_end"

    return "neutral"


# ==============================
# メイン予測ロジック（統合版）
# ==============================
def predict_fx(df: pd.DataFrame, N: int) -> dict:
    """
    修正版 predict_fx
    - 類似度ロジック修正
    - DTW 正規化
    - 特徴量スケール標準化
    - confidence 再設計
    - direction ロジック安定化
    """

    # -------------------------
    # 入力チェック
    # -------------------------
    required_cols = ['Open', 'High', 'Low', 'Close']
    for c in required_cols:
        if c not in df.columns:
            raise ValueError(f"DataFrame must contain column: {c}")

    # Volume が無い場合は 1 を入れる（0 は壊れる）
    if 'Volume' not in df.columns:
        df['Volume'] = 1.0

    total = len(df)
    if total < N + 3:
        raise ValueError("Not enough bars for the requested N and next3 calculation.")

    # -------------------------
    # ATR 計算（固定 14）
    # -------------------------
    ATR_PERIOD = 14
    highs = df['High'].values
    lows = df['Low'].values
    closes = df['Close'].values

    atr_series = fast_atr(highs, lows, closes, ATR_PERIOD)

    # -------------------------
    # 特徴量生成
    # -------------------------
    price_shape_mat = build_price_shape_features(df, N, atr_series)
    market_vol_mat = build_market_vol_features(df, N, atr_series)
    pattern_mat = np.hstack([price_shape_mat, market_vol_mat])

    windows = total - N + 1
    current_vec = pattern_mat[-1]

    # -------------------------
    # 過去パターン抽出
    # -------------------------
    valid_count_full = windows - 1
    start_idx = max(0, valid_count_full - MAX_HISTORY_WINDOWS)
    end_idx = valid_count_full
    valid_count = end_idx - start_idx

    past_mat = pattern_mat[start_idx:end_idx]

    # -------------------------
    # 価格シーケンス（DTW 用）
    # -------------------------
    price_seqs = []
    for i in range(windows):
        s = i
        e = i + N
        price_seqs.append(closes[s:e])
    price_seqs = np.array(price_seqs, dtype=float)

    current_price_seq = price_seqs[-1]
    past_price_seqs = price_seqs[start_idx:end_idx]

    # -------------------------
    # next3 ラベル生成
    # -------------------------
    direction_labels = np.zeros(valid_count, dtype=float)
    strength_labels = np.zeros(valid_count, dtype=float)
    volatility_labels = np.zeros(valid_count, dtype=float)
    next3_high_norm = np.zeros(valid_count, dtype=float)
    next3_low_norm  = np.zeros(valid_count, dtype=float)

    for idx, i in enumerate(range(start_idx, end_idx)):
        cur_close = closes[i + N - 1]
        next3 = closes[i + N:i + N + 3]
        if len(next3) == 0:
            continue

        next_high = np.max(next3)
        next_low  = np.min(next3)

        atr_ref = max(1e-8, atr_series[i + N - 1])

        move_up_norm   = (next_high - cur_close) / atr_ref
        move_down_norm = (cur_close - next_low) / atr_ref

        if move_up_norm > move_down_norm:
            direction_labels[idx] = 1
        elif move_down_norm > move_up_norm:
            direction_labels[idx] = -1
        else:
            direction_labels[idx] = 0

        strength_labels[idx] = max(move_up_norm, move_down_norm)
        volatility_labels[idx] = (next_high - next_low) / atr_ref

        next3_high_norm[idx] = move_up_norm
        next3_low_norm[idx]  = -move_down_norm

    # -------------------------
    # 類似度計算（修正版）
    # -------------------------
    atr_last = atr_series[-1]
    atr_hist = atr_series[-200:] if len(atr_series) > 200 else atr_series
    atr_z = (atr_last - atr_hist.mean()) / (atr_hist.std() + 1e-8)

    if atr_z > 1.0:
        dynamic_top_k = 150
    elif atr_z < -0.5:
        dynamic_top_k = 60
    else:
        dynamic_top_k = 100

    sims, cos_sims = compute_similarities_fast(
        current_vec,
        past_mat,
        current_price_seq,
        past_price_seqs,
        top_k=dynamic_top_k,
        dtw_window=max(5, N // 2),
    )

    # -------------------------
    # 類似パターン抽出（修正版）
    # -------------------------
    SIM_THRESHOLD = 0.4
    similar_mask = sims > SIM_THRESHOLD
    similar_count = int(np.sum(similar_mask))
    total_patterns = len(sims)

    if similar_count > 5:
        idx_use = np.where(similar_mask)[0]
    else:
        top_k2 = min(20, total_patterns)
        idx_use = np.argsort(-sims)[:top_k2]

    avg_dir = np.mean(direction_labels[idx_use])
    pattern_signal = int(np.sign(avg_dir)) if avg_dir != 0 else 0

    avg_strength   = float(np.clip(np.mean(strength_labels[idx_use]),   -3.0, 3.0))
    avg_volatility = float(np.clip(np.mean(volatility_labels[idx_use]),  0.0, 5.0))
    avg_high_norm  = float(np.clip(np.mean(next3_high_norm[idx_use]),  -3.0, 3.0))
    avg_low_norm   = float(np.clip(np.mean(next3_low_norm[idx_use]),   -3.0, 3.0))

    # confidence は「類似度の平均」を素直に使う
    pattern_confidence = float(np.clip(np.mean(sims[idx_use]), 0.0, 1.0))

    # -------------------------
    # 状態判定（修正版）
    # -------------------------
    cur_start = total - N
    cur_window = df.iloc[cur_start:cur_start + N].reset_index(drop=True)
    state = determine_state_dynamic(cur_window, atr_series, N)

    # -------------------------
    # range_position
    # -------------------------
    highs_win = cur_window["High"].values
    lows_win  = cur_window["Low"].values
    closes_win = cur_window["Close"].values

    range_high = np.max(highs_win)
    range_low  = np.min(lows_win)
    last_close_win = closes_win[-1]

    range_position = (last_close_win - range_low) / max((range_high - range_low), 1e-8)

    # -------------------------
    # price_signal
    # -------------------------
    bodies = cur_window['Close'].values - cur_window['Open'].values
    signs = np.sign(bodies[-5:]) if len(bodies) >= 5 else np.sign(bodies)
    price_signal = int(np.sign(np.sum(signs)))

    # -------------------------
    # direction（修正版）
    # -------------------------
    if state == "trend_up":
        direction = 1
    elif state == "trend_down":
        direction = -1
    elif state == "range_up":
        direction = 1 if range_position > 0.5 else -1
    elif state == "range_down":
        direction = -1 if range_position < 0.5 else 1
    elif state == "range_breakout":
        direction = 1 if price_signal > 0 else -1
    elif state == "trend_up_end":
        combined = price_signal + pattern_signal
        direction = -1 if combined <= 0 else 1
    elif state == "trend_down_end":
        combined = price_signal + pattern_signal
        direction = 1 if combined >= 0 else -1
    else:  # neutral
        combined = price_signal + pattern_signal
        direction = 1 if combined > 0 else -1

    # -------------------------
    # 高値・安値予測
    # -------------------------
    high_est = last_close_win + avg_high_norm * atr_last
    low_est  = last_close_win + avg_low_norm  * atr_last

    # -------------------------
    # confidence（修正版）
    # -------------------------
    confidence = float(np.clip(pattern_confidence, 0.05, 0.95))

    return {
        "last_close": float(last_close_win),
        "high_est": float(high_est),
        "low_est": float(low_est),
        "direction": int(direction),
        "confidence": float(confidence),
        "range_position": float(range_position),
        "state": state
    }

# ------------------------------------------------------------
# CSV 読み込み + 実行
# ------------------------------------------------------------
def load_and_predict(input_csv: str = input_path, N: int = 20):
    df = pd.read_csv(input_csv)
    for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
        if col in df.columns:
            df[col] = (
                pd.to_numeric(df[col], errors='coerce')
                .fillna(method='ffill')
                .fillna(0.0)
            )
    return predict_fx(df, N)


# ------------------------------------------------------------
# main
# ------------------------------------------------------------
if __name__ == "__main__":
    try:
        pred = load_and_predict(input_path, N=20)
        print(json.dumps(pred, ensure_ascii=False, indent=2))
    except Exception as e:
        print(json.dumps({"error": str(e)}, ensure_ascii=False, indent=2))
